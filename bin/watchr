#!/usr/bin/env ruby

require 'pathname'
require 'optparse'

require 'watchr'

module Watchr
  # Namespaced to avoid defining global methods
  module Bin #:nodoc:
    extend self

    def usage
      "Usage: watchr [opts] path/to/script"
    end

    def version
      "watchr version: %s" % Watchr::VERSION
    end

    # Find a partial path name in load path
    #
    # ===== Params
    # path<Pathname>:: partial pathname
    #
    # ===== Returns
    # <Pathname>::
    #   absolute path of first occurence of partial path in load path, or nil if not found
    #
    def find_in_load_path(path)
      dir = potentially_with_gem( path.basename('.watchr') ) do
        $LOAD_PATH.detect {|p| Pathname(p).join(path).exist? }
      end
      dir ? path.expand_path(dir) : nil
    end

    # Create a script file that loads autowatchr
    #
    # ===== Returns
    # script<File> or nil if autowatchr isn't installed
    #
    def autowatchr
      return nil unless have_autowatchr?

      @autowatchr ||= begin
        require 'tmpdir'
        file = Pathname(Dir.tmpdir) + 'auto.watchr'
        file.open('w') {|f|
          f << "require 'autowatchr'; Autowatchr.new(self)"
          f << "{|config| config.require='rubygems'}" if defined?(Gem)
        }
        file
      end
    end

    private

    # Wether the autowatchr gem is present on user's system
    #
    # ===== Returns
    # installed<bool>
    #
    def have_autowatchr?
      @have_autowatchr ||= begin
        require 'autowatchr'
      rescue LoadError
        false
      end
    end

    # If the block returns nil, requires gem <tt>name</tt> and tries running the
    # block again. If all fails, returns nil
    #
    # ===== Params
    # name<Pathname,String>:: name of gem to require
    #
    # ===== Returns
    # block's value or nil if gem <tt>name</tt> doesn't exist
    #
    def potentially_with_gem(name)
      yield || (require(name) && yield)
    rescue LoadError
      nil
    end
  end
end

opts = OptionParser.new do |opts|
  opts.banner = Watchr::Bin.usage

  opts.on('-d', '--debug', "Print extra debug info while program runs") {
    Watchr.options.debug = true
    begin
      require 'ruby-debug'
    rescue LoadError, RuntimeError
    end
  }

  opts.on_tail('-h', '--help', "Print inline help") { puts opts; exit }
  opts.on_tail('-v', '--version', "Print version" ) { puts Watchr::Bin.version; exit }

  opts.parse! ARGV
end

file =
  if ARGV.first.nil?
    Watchr::Bin.autowatchr or abort(<<-END.gsub(/^\s*/,''))
      #{Watchr::Bin.usage}
      Or install autowatchr to get default functionality (gem install autowatchr --source http://gemcutter.org)
    END
  else
    Watchr::Bin.find_in_load_path(Pathname(ARGV.first)) or abort <<-END.gsub(/^\s*/,'')
      no script found; file #{relative_path.to_s.inspect} is not in path.
    END
  end

Watchr::Controller.new(Watchr::Script.new(file), Watchr.handler.new).run

